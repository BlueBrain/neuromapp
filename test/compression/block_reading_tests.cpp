#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>

#include <sstream>
#include <string>

#define BOOST_TEST_MODULE devin_block_test
#include <boost/mpl/list.hpp>
#include <boost/test/unit_test.hpp>


#include "compression/allocator.h"
#include "compression/exception.h"
#include "compression/block.h"
using neuromapp::block;
using neuromapp::cstandard;
using namespace std;

//use raw string literals for easier creation of varied tests for read
string s1 {R"(4,5
1, 2, 5, 45,
1, 2, 5, 45,
1, 2, 5, 45,
1, 2, 5, 45,
1, 2, 5, 45)"};

string s1_correct {R"(1 2 5 45
1 2 5 45
1 2 5 45
1 2 5 45
1 2 5 45)"};


string s2 {R"(10,15
208,542,532,182,73,843,24,676,393,878
444,575,499,321,896,46,973,180,184,107
359,159,976,315,103,136,183,365,84,935
417,821,604,549,914,462,880,702,773,427
56,149,60,787,113,595,997,411,606,875
201,489,287,327,777,330,441,92,113,767
334,339,850,822,832,633,394,697,4,271
448,459,327,159,365,158,24,131,389,193
613,45,148,169,13,678,61,848,903,365
338,700,491,261,245,491,330,710,490,795
626,256,969,110,55,440,999,251,864,862
50,93,214,844,914,620,863,659,739,259
637,909,502,683,175,789,270,528,205,581
248,446,309,942,144,598,773,403,994,487
618,497,955,125,230,834,894,224,828,936)"};

string s2_correct {R"(208 542 532 182 73 843 24 676 393 878
444 575 499 321 896 46 973 180 184 107
359 159 976 315 103 136 183 365 84 935
417 821 604 549 914 462 880 702 773 427
56 149 60 787 113 595 997 411 606 875
201 489 287 327 777 330 441 92 113 767
334 339 850 822 832 633 394 697 4 271
448 459 327 159 365 158 24 131 389 193
613 45 148 169 13 678 61 848 903 365
338 700 491 261 245 491 330 710 490 795
626 256 969 110 55 440 999 251 864 862
50 93 214 844 914 620 863 659 739 259
637 909 502 683 175 789 270 528 205 581
248 446 309 942 144 598 773 403 994 487
618 497 955 125 230 834 894 224 828 936)"};

string s3 {R"(6,16
0.0, 0.00010101010101010101, 0.00020202020202020202, 0.00030303030303030303, 0.00040404040404040404, 0.00050505050505050505,
0.00060606060606060606, 0.00070707070707070707, 0.00080808080808080808, 0.00090909090909090909, 0.0010101010101010101, 0.0011111111111111111,
0.0012121212121212121, 0.0013131313131313131, 0.0014141414141414141, 0.0015151515151515152, 0.0016161616161616162, 0.0017171717171717172,
0.0018181818181818182, 0.0019191919191919192, 0.0020202020202020202, 0.002121212121212121, 0.0022222222222222222, 0.0023232323232323234,
0.0024242424242424242, 0.002525252525252525, 0.0026262626262626263, 0.0027272727272727275, 0.0028282828282828283, 0.0029292929292929291,
0.0030303030303030303, 0.0031313131313131315, 0.0032323232323232323, 0.0033333333333333331, 0.0034343434343434343, 0.0035353535353535356,
0.0036363636363636364, 0.0037373737373737372, 0.0038383838383838384, 0.0039393939393939396, 0.0040404040404040404, 0.0041414141414141412,
0.004242424242424242, 0.0043434343434343436, 0.0044444444444444444, 0.0045454545454545452, 0.0046464646464646469, 0.0047474747474747477,
0.0048484848484848485, 0.0049494949494949493, 0.0050505050505050501, 0.0051515151515151517, 0.0052525252525252525, 0.0053535353535353533,
0.005454545454545455, 0.0055555555555555558, 0.0056565656565656566, 0.0057575757575757574, 0.0058585858585858581, 0.0059595959595959598,
0.0060606060606060606, 0.0061616161616161614, 0.0062626262626262631, 0.0063636363636363638, 0.0064646464646464646, 0.0065656565656565654,
0.0066666666666666662, 0.0067676767676767679, 0.0068686868686868687, 0.0069696969696969695, 0.0070707070707070711, 0.0071717171717171719,
0.0072727272727272727, 0.0073737373737373735, 0.0074747474747474743, 0.007575757575757576, 0.0076767676767676768, 0.0077777777777777776,
0.0078787878787878792, 0.0079797979797979791, 0.0080808080808080808, 0.0081818181818181825, 0.0082828282828282824, 0.008383838383838384,
0.008484848484848484, 0.0085858585858585856, 0.0086868686868686873, 0.0087878787878787872, 0.0088888888888888889, 0.0089898989898989905,
0.0090909090909090905, 0.0091919191919191921, 0.0092929292929292938, 0.0093939393939393937, 0.0094949494949494954, 0.0095959595959595953)"};

string s3_correct {R"(0.0 0.00010101010101010101 0.00020202020202020202 0.00030303030303030303 0.00040404040404040404 0.00050505050505050505
0.00060606060606060606 0.00070707070707070707 0.00080808080808080808 0.00090909090909090909 0.0010101010101010101 0.0011111111111111111
0.0012121212121212121 0.0013131313131313131 0.0014141414141414141 0.0015151515151515152 0.0016161616161616162 0.0017171717171717172
0.0018181818181818182 0.0019191919191919192 0.0020202020202020202 0.002121212121212121 0.0022222222222222222 0.0023232323232323234
0.0024242424242424242 0.002525252525252525 0.0026262626262626263 0.0027272727272727275 0.0028282828282828283 0.0029292929292929291
0.0030303030303030303 0.0031313131313131315 0.0032323232323232323 0.0033333333333333331 0.0034343434343434343 0.0035353535353535356
0.0036363636363636364 0.0037373737373737372 0.0038383838383838384 0.0039393939393939396 0.0040404040404040404 0.0041414141414141412
0.004242424242424242 0.0043434343434343436 0.0044444444444444444 0.0045454545454545452 0.0046464646464646469 0.0047474747474747477
0.0048484848484848485 0.0049494949494949493 0.0050505050505050501 0.0051515151515151517 0.0052525252525252525 0.0053535353535353533
0.005454545454545455 0.0055555555555555558 0.0056565656565656566 0.0057575757575757574 0.0058585858585858581 0.0059595959595959598
0.0060606060606060606 0.0061616161616161614 0.0062626262626262631 0.0063636363636363638 0.0064646464646464646 0.0065656565656565654
0.0066666666666666662 0.0067676767676767679 0.0068686868686868687 0.0069696969696969695 0.0070707070707070711 0.0071717171717171719
0.0072727272727272727 0.0073737373737373735 0.0074747474747474743 0.007575757575757576 0.0076767676767676768 0.0077777777777777776
0.0078787878787878792 0.0079797979797979791 0.0080808080808080808 0.0081818181818181825 0.0082828282828282824 0.008383838383838384
0.008484848484848484 0.0085858585858585856 0.0086868686868686873 0.0087878787878787872 0.0088888888888888889 0.0089898989898989905
0.0090909090909090905 0.0091919191919191921 0.0092929292929292938 0.0093939393939393937 0.0094949494949494954 0.0095959595959595953)"};

string s4 {""};
string s4_correct{""};

//error causing entries
//should throw some kind dimension error
string s5 {R"(1,5
178e2, 31006, 165e6, 18772,
2e576, e00, 10008, 23764, 23698, 26443, 2685, 6515, 28810, 13910, 20320, 19405, 31808,
A:F, EIDKL, FEEDK,CCLEECC,CEKLDE,CCDHLF,ECCDIH,FCCCEF,HICCCE,IDHDCC,HFDLCC,LLLECC,EGLJJC,CEGJKJC,
)"};

string s6 {R"(1,5
17812, 31006, 16516, 18772,
21576, 100, 10008 23764 2369826443               2685,


6515, 28810, 13910, 20320, 19405, 31808,
)"};

string s7 {R"(broken,5
17842, 31006, 16546, 18772,
24576, 400, 10008, 23764, 23698, 26443, 2685, 6515, 28810, 13910, 20320, 19405, 31808,
8303, 26189, 32218, 9220, 28912, 15932, 16530, 23564, 26151, 5319, 9992, 24977, 24787,
)"};


string s8 {R"(1,5,6,1
17842, 31006, 16546, 18772,
24576, 400, 10008, 23764, 23698, 26443, 2685, 6515, 28810, 13910, 20320, 19405, 31808,
8303, 26189, 32218, 9220, 28912, 15932, 16530, 23564, 26151, 5319, 9992, 24977, 24787,
)"};


string s9 {R"(1,5
17842, 31006, 16546, 18772,
24576, 400, 10008, 23764, 23698, 26443, 2685, 6515, 28810, 13910, 20320, 19405, 31808,
8303, 26189, 32218, 9220, 28912, 15932, 16530, 23564, 26151, 5319, 9992, 24977, 24787,
)"};

//holder struct for combos of numeric type and allocator policy
template <class T,class A>
struct shell {
    typedef T value_type;
    typedef A allocator_type;
};

//should I be testing the align this whole time?
typedef boost::mpl::list<shell<float, neuromapp::cstandard>,
                        shell<int, neuromapp::cstandard>,
                         shell<double, neuromapp::cstandard>>
    test_allocator_types;



// use lists to facilitate ease when checking various options
vector<string> start_string_vect {s2};
vector<string> correct_string_vect {s2_correct};
BOOST_AUTO_TEST_CASE_TEMPLATE( read_test,T,test_allocator_types) {
    //use counter to control testing on strings that have correct versions given
    int correct_counter =0;
    // TODO ask tim about this syntax
    typedef typename T::value_type value_type;
    typedef typename T::allocator_type allocator_type;
    for (string str : start_string_vect) {
        stringstream ss,ss2;
        std::cout << "correct count is " << correct_counter << std::endl;
        string correct_str = correct_string_vect[correct_counter];
        ss << str;
        block<value_type,allocator_type> b1;
        //check basic error catching
        BOOST_CHECK_MESSAGE(ss >> b1,
                "string was\n"<<str);
        //capture output of block print
        // block output has no separating commas
        ss2 << b1;
        BOOST_CHECK_MESSAGE(ss2.str() == correct_str,
                "failed comparison: string was\n" << correct_str+"\n" << "block was\n" << ss2.str());
        //mem cmp test
        //built by file, now by hand for comparison
//        std_block b2(4,5);
//        for (int i = 0; i < b2.num_rows();i++) {
//            //this is the first by hand way of checking this I could think of
//            for (int j = 0;j < b2.num_cols(); j++) {
//            //use static casts based on value_type to make the conversion from string to block element easier
//                b2(j,i) = vals[j];
//            }
//        }
//        BOOST_CHECK(b1==b2);
    }
}

